#!/usr/bin/env bash
set -Euo pipefail
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
. "$SCRIPT_DIR/agentd-common"

usage() {
  cat <<USAGE
usage: job-run "<command to run>"
  Runs the command in a new tmux window under session "$AGENTD_SESSION".
  Streams output to ~/.agentd/logs/<token>.log, forwards [notify] lines
  to agent-notify, and sends completion back to the original CLI pane.

env:
  AGENTD_SESSION   tmux session (default: agentd)
  JOB_TOKEN        preset token (default: autogenerated)
  JOB_TARGET_PANE  explicit pane (session:win.pane) to send completion to
  JOB_MAX_SEC      kill job after N seconds (default: 0 = no timeout)
  JOB_WAIT_SEC     waiter timeout for completion signal (default: 600)
USAGE
}

if [[ $# -lt 1 ]]; then
  usage; exit 2
fi

require_tmux
tmux start-server

cmd_string=$1

token=${JOB_TOKEN:-job-$(date +%Y%m%d%H%M%S)-$(agentd_rand)}
run_dir="$AGENTD_DIR/run"; mkdir -p "$run_dir"
rc_file="$AGENTD_DIR/$token.rc"
log_file="$AGENTD_LOGDIR/$token.log"
runner="$run_dir/$token.sh"
tmux_bin=$(command -v tmux || echo tmux)

# Build runner script with embedded parameters to avoid arg quoting issues
q_cmd=$(printf '%q' "$cmd_string")
q_rc=$(printf '%q' "$rc_file")
q_tok=$(printf '%q' "$token")
cat >"$runner" <<RUN
#!/usr/bin/env bash
set +e
cmd_string=$q_cmd
rc_file=$q_rc
token=$q_tok
rc=0
{
  if [[ -n "
\${JOB_MAX_SEC:-}" && "\${JOB_MAX_SEC:-0}" -gt 0 ]] && command -v timeout >/dev/null 2>&1; then
    timeout -s TERM "\${JOB_MAX_SEC}" bash -lc "\$cmd_string"
  else
    bash -lc "\$cmd_string"
  fi
} || rc=\$?
echo "\$rc" > "\$rc_file"
__TMUX_BIN__ wait-for -S "\$token"
exit "\$rc"
RUN
sed -i -e "s#__TMUX_BIN__#$(printf '%s' "$tmux_bin" | sed 's/[\\&]/\\&/g')#g" "$runner"

chmod +x "$runner"

# Create a tiny launcher that just execs runner (no args needed)
launcher="$run_dir/$token.launch.sh"
cat >"$launcher" <<EOF
#!/usr/bin/env bash
echo "LAUNCHER start \\$(date -Is) uid=\\$UID shell=\\$SHELL" >> "$run_dir/$token.exec.log"
exec "$runner"
EOF
chmod +x "$launcher"

# Resolve and freeze target pane now (reliable completion delivery) and derive job session dynamically
resolved_target=""
if [[ -n "${JOB_TARGET_PANE:-}" ]]; then
  resolved_target="$JOB_TARGET_PANE"
else
  # Self-only resolver (agentd-send will fail if not inside tmux)
  resolved_target=$(AGENTD_RESOLVE_ONLY=1 "$SCRIPT_DIR/agentd-send" --resolve-only 2>/dev/null | tail -n1 || true)
  if [[ -z "$resolved_target" ]]; then
    echo "error: could not resolve target pane (run inside tmux or set JOB_TARGET_PANE)" >&2
    exit 2
  fi
fi
target_file="$AGENTD_DIR/$token.target"
if [[ -n "$resolved_target" ]]; then printf '%s\n' "$resolved_target" >"$target_file"; fi

# Determine job session from target pane (session:win.pane) or fallback
job_session=${JOB_SESSION:-}
if [[ -z "$job_session" ]]; then
  job_session=$(printf '%s' "$resolved_target" | awk -F: '{print $1}')
fi
if [[ -z "$job_session" ]]; then
  job_session="$AGENTD_SESSION"
fi

# Ensure the job session exists and set remain-on-exit before creating the window
if ! tmux has-session -t "$job_session" 2>/dev/null; then
  tmux new-session -d -s "$job_session" -n cli 'bash -lc "exec bash -i"'
fi
tmux set-option -t "$job_session" remain-on-exit on >/dev/null 2>&1 || true

# Create new job window first with safe-quoted args
cmd_arg=$(printf '%q' "$cmd_string")
rcf_arg=$(printf '%q' "$rc_file")
tok_arg=$(printf '%q' "$token")
sess_arg=$(printf '%q' "$job_session")
tmux new-window -d -t "$job_session" -n "$token" "bash $launcher"
# Record window index and pane/window ids for reliable attach later
win_idx=""; win_id=""; pane_id=""
for i in 1 2 3 4 5; do
  win_idx=$(tmux display-message -p -t "$job_session:$token" '#{window_index}' 2>/dev/null || true)
  win_id=$(tmux display-message -p -t "$job_session:$token" '#{window_id}' 2>/dev/null || true)
  pane_id=$(tmux list-panes -t "$job_session:$token" -F '#{pane_id}' 2>/dev/null | head -n1 || true)
  [[ -n "$win_idx" && -n "$win_id" && -n "$pane_id" ]] && break
  sleep 0.05
done
if [[ -n "$win_idx" ]]; then echo "$win_idx" >"$AGENTD_DIR/$token.win"; fi
if [[ -n "$win_id" ]]; then echo "$win_id" >"$AGENTD_DIR/$token.wid"; fi
if [[ -n "$pane_id" ]]; then echo "$pane_id" >"$AGENTD_DIR/$token.pid"; fi

# Attach logging/notify pipe (idempotent with -o) to the pane id; retry briefly to avoid race
FILTER_CMD="$SCRIPT_DIR/agentd-filter"
pipe_ok=0
for i in 1 2 3 4 5 6 7 8 9 10; do
  if [[ -n "$pane_id" ]]; then
    if tmux pipe-pane -t "$pane_id" -o "bash -lc 'exec \"$FILTER_CMD\" \"$log_file\"'" >/dev/null 2>&1; then
      pipe_ok=1; break
    fi
  elif [[ -n "$win_id" ]]; then
    if tmux pipe-pane -t "$win_id" -o "bash -lc 'exec \"$FILTER_CMD\" \"$log_file\"'" >/dev/null 2>&1; then
      pipe_ok=1; break
    fi
  fi
  sleep 0.1
done
if [[ $pipe_ok -ne 1 ]]; then
  echo "PIPE_ATTACH_FAILED $token target=${pane_id:-$win_id} log=$log_file" >>"$run_dir/$token.exec.log"
fi

# Link the job window into a dedicated viewer session so users can attach there safely
VIEW_SESSION=${AGENTD_VIEW_SESSION:-agentview}
if ! tmux has-session -t "$VIEW_SESSION" 2>/dev/null; then
  tmux new-session -d -s "$VIEW_SESSION" -n cli 'bash -lc "exec bash -i"'
fi
# Link using window-id to avoid name races; name the linked window as token
if [[ -n "$win_id" ]]; then
  tmux link-window -k -s "$win_id" -t "$VIEW_SESSION:$token" >/dev/null 2>&1 || \
  tmux link-window    -s "$win_id" -t "$VIEW_SESSION:$token" >/dev/null 2>&1 || true
  tmux set-window-option -t "$VIEW_SESSION:$token" remain-on-exit on >/dev/null 2>&1 || true
fi

# Additionally, spawn a viewer window that tails the job log (works even if link-window fails)
if tmux list-windows -t "$VIEW_SESSION" -F '#{window_name}' 2>/dev/null | grep -Fxq "$token"; then
  tmux kill-window -t "$VIEW_SESSION:$token" >/dev/null 2>&1 || true
fi
tmux new-window -d -t "$VIEW_SESSION" -n "$token" \
  "bash -lc 'printf \"tailing %s\\n\" \"$log_file\"; i=0; while [ ! -s \"$log_file\" ] && [ \"$i\" -lt 50 ]; do sleep 0.1; i=$((i+1)); done; tail -n +1 -f \"$log_file\"'" >/dev/null 2>&1 || true

# 提示: 実行中のジョブ画面をすぐ見たい場合のtmuxコマンド（stderrに表示）
{
  echo "view (outside tmux): tmux attach -t '$VIEW_SESSION' \; select-window -t '$VIEW_SESSION:$token'"
  echo "view (inside tmux):  tmux select-window -t '$VIEW_SESSION:$token'"
} >&2

# Note: Do not send the attach command to the pane. We only print
# copyable hints to stderr above; users/MCP clients surface commands.

# Wait for completion signal (with timeout), then send message and robust newline(s)
# Keep rc/target files for post-mortem/MCP status reads
tmux run-shell "sh -lc '
  to=0;
  if command -v timeout >/dev/null 2>&1; then
    timeout \"${JOB_WAIT_SEC:-600}\" tmux wait-for $token || to=1;
  else
    tmux wait-for $token || to=1;
  fi;
  rc=255; test -f \"$rc_file\" && rc=\$(cat \"$rc_file\");
  AGENTD_TARGET_PANE=\"$resolved_target\" \"$SCRIPT_DIR/agentd-send\" \"[notify] job $token done rc=\$rc timeout=\$to\"'
"

echo "$token"
