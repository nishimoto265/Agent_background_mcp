#!/usr/bin/env bash
set -Euo pipefail
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
. "$SCRIPT_DIR/agentd-common"

usage() {
  cat <<USAGE
usage: job-run "<command to run>"
  Runs the command in a new tmux window under session "$AGENTD_SESSION".
  Streams output to ~/.agentd/logs/<token>.log, forwards [notify] lines
  to agent-notify, and sends completion back to the original CLI pane.

env:
  AGENTD_SESSION   tmux session (default: agentd)
  JOB_TOKEN        preset token (default: autogenerated)
  JOB_TARGET_PANE  explicit pane (session:win.pane) to send completion to
  JOB_MAX_SEC      kill job after N seconds (default: 0 = no timeout)
  JOB_WAIT_SEC     waiter timeout for completion signal (default: 600)
USAGE
}

if [[ $# -lt 1 ]]; then
  usage; exit 2
fi

require_tmux
tmux start-server

cmd_string=$1

token=${JOB_TOKEN:-job-$(date +%Y%m%d%H%M%S)-$(agentd_rand)}
run_dir="$AGENTD_DIR/run"; mkdir -p "$run_dir"
rc_file="$AGENTD_DIR/$token.rc"
runner="$run_dir/$token.sh"
tmux_bin=$(command -v tmux || echo tmux)

# Build runner script with embedded parameters to avoid arg quoting issues
q_cmd=$(printf '%q' "$cmd_string")
q_rc=$(printf '%q' "$rc_file")
q_tok=$(printf '%q' "$token")
cat >"$runner" <<RUN
#!/usr/bin/env bash
set +e
cmd_string=$q_cmd
rc_file=$q_rc
token=$q_tok
rc=0
{
  if [[ -n "
\${JOB_MAX_SEC:-}" && "\${JOB_MAX_SEC:-0}" -gt 0 ]] && command -v timeout >/dev/null 2>&1; then
    timeout -s TERM "\${JOB_MAX_SEC}" bash -lc "\$cmd_string"
  else
    bash -lc "\$cmd_string"
  fi
} || rc=\$?
echo "\$rc" > "\$rc_file"
__TMUX_BIN__ wait-for -S "\$token"
exit "\$rc"
RUN
sed -i -e "s#__TMUX_BIN__#$(printf '%s' "$tmux_bin" | sed 's/[\\&]/\\&/g')#g" "$runner"

chmod +x "$runner"

# Create a tiny launcher that just execs runner (no args needed)
launcher="$run_dir/$token.launch.sh"
cat >"$launcher" <<EOF
#!/usr/bin/env bash
echo "LAUNCHER start \\$(date -Is) uid=\\$UID shell=\\$SHELL" >> "$run_dir/$token.exec.log"
"$(command -v tmux || echo tmux)" wait-for "$token.pipe"
exec "$runner"
EOF
chmod +x "$launcher"

# Resolve and freeze target pane now (reliable completion delivery) and derive job session dynamically
resolved_target=""
if [[ -n "${JOB_TARGET_PANE:-}" ]]; then
  resolved_target="$JOB_TARGET_PANE"
else
  # Self-only resolver (agentd-send will fail if not inside tmux)
  resolved_target=$(AGENTD_RESOLVE_ONLY=1 "$SCRIPT_DIR/agentd-send" --resolve-only 2>/dev/null | tail -n1 || true)
  if [[ -z "$resolved_target" ]]; then
    echo "error: could not resolve target pane (run inside tmux or set JOB_TARGET_PANE)" >&2
    exit 2
  fi
fi
target_file="$AGENTD_DIR/$token.target"
if [[ -n "$resolved_target" ]]; then printf '%s\n' "$resolved_target" >"$target_file"; fi

# Determine execution session according to mode (self|fixed|per_repo)
# - self: use original session of resolved_target
# - fixed: use AGENTD_EXEC_SESSION (default: agentexec)
# - per_repo (default): exec-<basename of pane cwd>
exec_mode=${AGENTD_EXEC_SESSION_MODE:-per_repo}
pane_cwd=$(tmux display-message -p -t "$resolved_target" '#{pane_current_path}' 2>/dev/null || printf '%s' "$PWD")
repo_base=$(basename -- "$pane_cwd")
job_session=${JOB_SESSION:-}
if [[ -z "$job_session" ]]; then
  case "$exec_mode" in
    self)
      job_session=$(printf '%s' "$resolved_target" | awk -F: '{print $1}') ;;
    fixed)
      job_session=${AGENTD_EXEC_SESSION:-agentexec} ;;
    per_repo|*)
      job_session=${AGENTD_EXEC_SESSION:-exec-$repo_base} ;;
  esac
fi
if [[ -z "$job_session" ]]; then job_session="$AGENTD_SESSION"; fi

# Decide log directory based on target pane's current path if not explicitly set
if [[ -z "${AGENTD_LOGDIR:-}" ]]; then
  AGENTD_LOGDIR="$pane_cwd/mcp_log"
fi
mkdir -p "$AGENTD_LOGDIR" 2>/dev/null || true
log_file="$AGENTD_LOGDIR/$token.log"

# Ensure the job session exists and set remain-on-exit before creating the window
if ! tmux has-session -t "$job_session" 2>/dev/null; then
  tmux new-session -d -s "$job_session" -n cli 'bash -lc "exec bash -i"'
fi
tmux set-option -t "$job_session" remain-on-exit on >/dev/null 2>&1 || true

# Create new job window first with safe-quoted args
cmd_arg=$(printf '%q' "$cmd_string")
rcf_arg=$(printf '%q' "$rc_file")
tok_arg=$(printf '%q' "$token")
sess_arg=$(printf '%q' "$job_session")
tmux new-window -d -t "$job_session" -n "$token" -c "$pane_cwd" "bash $launcher"
# Record window index and pane/window ids for reliable attach later
win_idx=""; win_id=""; pane_id=""
for i in 1 2 3 4 5; do
  win_idx=$(tmux display-message -p -t "$job_session:$token" '#{window_index}' 2>/dev/null || true)
  win_id=$(tmux display-message -p -t "$job_session:$token" '#{window_id}' 2>/dev/null || true)
  pane_id=$(tmux list-panes -t "$job_session:$token" -F '#{pane_id}' 2>/dev/null | head -n1 || true)
  [[ -n "$win_idx" && -n "$win_id" && -n "$pane_id" ]] && break
  sleep 0.05
done
if [[ -n "$win_idx" ]]; then echo "$win_idx" >"$AGENTD_DIR/$token.win"; fi
if [[ -n "$win_id" ]]; then echo "$win_id" >"$AGENTD_DIR/$token.wid"; fi
if [[ -n "$pane_id" ]]; then echo "$pane_id" >"$AGENTD_DIR/$token.pid"; fi
if [[ -n "$win_id" ]]; then
  # Keep this job window visible after command exits (per-window remain-on-exit)
  tmux set-window-option -t "$win_id" remain-on-exit on >/dev/null 2>&1 || true
fi

# Attach logging/notify pipe (idempotent with -o) to the pane id; retry briefly to avoid race
FILTER_CMD="$SCRIPT_DIR/agentd-filter"
pipe_ok=0
for i in 1 2 3 4 5 6 7 8 9 10; do
  if [[ -n "$pane_id" ]]; then
    if tmux pipe-pane -t "$pane_id" -o "bash -lc 'exec \"$FILTER_CMD\" \"$log_file\"'" >/dev/null 2>&1; then
      pipe_ok=1; break
    fi
  elif [[ -n "$win_id" ]]; then
    if tmux pipe-pane -t "$win_id" -o "bash -lc 'exec \"$FILTER_CMD\" \"$log_file\"'" >/dev/null 2>&1; then
      pipe_ok=1; break
    fi
  fi
  sleep 0.1
done
if [[ $pipe_ok -ne 1 ]]; then
  echo "PIPE_ATTACH_FAILED $token target=${pane_id:-$win_id} log=$log_file" >>"$run_dir/$token.exec.log"
fi

# Viewer session is not used when executing in a dedicated execution session

# 提示: 実行中のジョブ画面をすぐ見たい場合のtmuxコマンド（stderrに表示）
{
  echo "view (outside tmux): tmux attach -t '$job_session' \; select-window -t '$job_session:$token'"
  echo "view (inside tmux):  tmux select-window -t '$job_session:$token'"
} >&2

# Signal launcher that pipe is attached; safe to start the runner command
tmux run-shell "tmux wait-for -S '$token.pipe'"

# Note: Do not send the attach command to the pane. We only print
# copyable hints to stderr above; users/MCP clients surface commands.

# Wait for completion signal and notify via external helper (robust against quoting)
tmux run-shell "$SCRIPT_DIR/job-wait-notify '$token' '${JOB_WAIT_SEC:-600}' '$rc_file' '$resolved_target' '$run_dir' '$SCRIPT_DIR' '${JOB_NOTIFY_PANE:-}'"

echo "$token"
