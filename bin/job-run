#!/usr/bin/env bash
set -Euo pipefail
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
. "$SCRIPT_DIR/agentd-common"

usage() {
  cat <<USAGE
usage: job-run "<command to run>"
  Runs the command in a new tmux window under session "$AGENTD_SESSION".
  Streams output to ~/.agentd/logs/<token>.log, forwards [notify] lines
  to agent-notify, and sends completion back to the original CLI pane.

env:
  AGENTD_SESSION   tmux session (default: agentd)
  JOB_TOKEN        preset token (default: autogenerated)
  JOB_TARGET_PANE  explicit pane (session:win.pane) to send completion to
  JOB_MAX_SEC      kill job after N seconds (default: 0 = no timeout)
  JOB_WAIT_SEC     waiter timeout for completion signal (default: 600)
USAGE
}

if [[ $# -lt 1 ]]; then
  usage; exit 2
fi

require_tmux
tmux start-server

cmd_string=$1

token=${JOB_TOKEN:-job-$(date +%Y%m%d%H%M%S)-$(agentd_rand)}
run_dir="$AGENTD_DIR/run"; mkdir -p "$run_dir"
rc_file="$AGENTD_DIR/$token.rc"
log_file="$AGENTD_LOGDIR/$token.log"
runner="$run_dir/$token.sh"
tmux_bin=$(command -v tmux || echo tmux)

# Build runner script that accepts (cmd_string, rc_file, token) as args
cat >"$runner" <<'RUN'
#!/usr/bin/env bash
set +e
cmd_string=${1:?}
rc_file=${2:?}
token=${3:?}
job_session=${4:-}
rc=0
{
  if [[ -n "${JOB_MAX_SEC:-}" && "${JOB_MAX_SEC:-0}" -gt 0 ]] && command -v timeout >/dev/null 2>&1; then
    timeout -s TERM "${JOB_MAX_SEC}" bash -lc "$cmd_string"
  else
    bash -lc "$cmd_string"
  fi
} || rc=$?
echo "$rc" > "$rc_file"
__TMUX_BIN__ wait-for -S "$token"
exit "$rc"
RUN
sed -i -e "s#__TMUX_BIN__#$(printf '%s' "$tmux_bin" | sed 's/[\\&]/\\&/g')#g" "$runner"

chmod +x "$runner"

# Create a tiny launcher to avoid complex tmux quoting issues
launcher="$run_dir/$token.launch.sh"
cat >"$launcher" <<EOF
#!/usr/bin/env bash
exec >> "$run_dir/$token.exec.log" 2>&1
echo "LAUNCHER start \\$(date -Is) uid=\\$UID shell=\\$SHELL"
set -x
exec "$runner" $(printf '%q ' "$cmd_string" "$rc_file" "$token" "$job_session")
EOF
chmod +x "$launcher"

# Resolve and freeze target pane now (reliable completion delivery) and derive job session dynamically
resolved_target=""
if [[ -n "${JOB_TARGET_PANE:-}" ]]; then
  resolved_target="$JOB_TARGET_PANE"
else
  # Self-only resolver (agentd-send will fail if not inside tmux)
  resolved_target=$(AGENTD_RESOLVE_ONLY=1 "$SCRIPT_DIR/agentd-send" --resolve-only 2>/dev/null | tail -n1 || true)
  if [[ -z "$resolved_target" ]]; then
    echo "error: could not resolve target pane (run inside tmux or set JOB_TARGET_PANE)" >&2
    exit 2
  fi
fi
target_file="$AGENTD_DIR/$token.target"
if [[ -n "$resolved_target" ]]; then printf '%s\n' "$resolved_target" >"$target_file"; fi

# Determine job session from target pane (session:win.pane) or fallback
job_session=${JOB_SESSION:-}
if [[ -z "$job_session" ]]; then
  job_session=$(printf '%s' "$resolved_target" | awk -F: '{print $1}')
fi
if [[ -z "$job_session" ]]; then
  job_session="$AGENTD_SESSION"
fi

# Ensure the job session exists so new-window succeeds
if ! tmux has-session -t "$job_session" 2>/dev/null; then
  tmux new-session -d -s "$job_session" -n cli 'bash -lc "exec bash -i"'
fi

# Create new job window first with safe-quoted args
cmd_arg=$(printf '%q' "$cmd_string")
rcf_arg=$(printf '%q' "$rc_file")
tok_arg=$(printf '%q' "$token")
sess_arg=$(printf '%q' "$job_session")
tmux new-window -d -t "$job_session" -n "$token" "bash '$launcher'"
# Keep the job window visible after the command exits for easier inspection
tmux set-window-option -t "$job_session:$token" remain-on-exit on >/dev/null 2>&1 || \
tmux set-option -t "$job_session:$token" remain-on-exit on >/dev/null 2>&1 || true

# Attach logging/notify pipe (idempotent with -o) using absolute path
FILTER_CMD="$SCRIPT_DIR/agentd-filter"
tmux pipe-pane -t "$job_session:$token" -o "bash -lc 'exec \"$FILTER_CMD\" \"$log_file\"'"

# 提示: 実行中のジョブ画面をすぐ見たい場合のtmuxコマンド（stderrに表示）
{
  echo "view (outside tmux): tmux attach -t '$job_session' \; select-window -t '$job_session:$token'"
  echo "view (inside tmux):  tmux select-window -t '$job_session:$token'"
} >&2

# Note: Do not send the attach command to the pane. We only print
# copyable hints to stderr above; users/MCP clients surface commands.

# Wait for completion signal (with timeout), then send message and robust newline(s)
# Keep rc/target files for post-mortem/MCP status reads
tmux run-shell "sh -lc '
  to=0;
  if command -v timeout >/dev/null 2>&1; then
    timeout \"${JOB_WAIT_SEC:-600}\" tmux wait-for $token || to=1;
  else
    tmux wait-for $token || to=1;
  fi;
  rc=255; test -f \"$rc_file\" && rc=\$(cat \"$rc_file\");
  AGENTD_TARGET_PANE=\"$resolved_target\" \"$SCRIPT_DIR/agentd-send\" \"[notify] job $token done rc=\$rc timeout=\$to\"'
"

echo "$token"
